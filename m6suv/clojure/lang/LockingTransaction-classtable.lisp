; LockingTransaction-classtable.lisp
; Automatically generated by jvm2acl2 on Tue May 27 00:28:52 CDT 2014.
;

(defconst *clojure.lang.LockingTransaction*
 (make-class-def
      '(class "clojure.lang.LockingTransaction"
            "java.lang.Object"
            (constant_pool
                        (INT 10000)
                        (INT 100)
                        (LONG 10000000)
                        (INT 0)
                        (INT 1)
                        (INT 2)
                        (INT 3)
                        (INT 4)
                        (LONG 100)
                        (STRING  "No transaction running")
                        (STRING  "Transaction failed after reaching retry limit")
                        (STRING  " is unbound.")
                        (STRING  "Can\nt set after commute"))
            (fields
                        (field "RETRY_LIMIT" int (accessflags  *class*  *final*  *public*  *static* ) 0)
                        (field "LOCK_WAIT_MSECS" int (accessflags  *class*  *final*  *public*  *static* ) 1)
                        (field "BARGE_WAIT_NANOS" long (accessflags  *class*  *final*  *public*  *static* ) 2)
                        (field "RUNNING" int (accessflags  *class*  *final*  *static* ) 3)
                        (field "COMMITTING" int (accessflags  *class*  *final*  *static* ) 4)
                        (field "RETRY" int (accessflags  *class*  *final*  *static* ) 5)
                        (field "KILLED" int (accessflags  *class*  *final*  *static* ) 6)
                        (field "COMMITTED" int (accessflags  *class*  *final*  *static* ) 7)
                        (field "transaction" (class "java.lang.ThreadLocal") (accessflags  *class*  *final*  *static* ) -1)
                        (field "lastPoint" (class "java.util.concurrent.atomic.AtomicLong") (accessflags  *class*  *final*  *private*  *static* ) -1)
                        (field "info" (class "clojure.lang.LockingTransaction$Info") (accessflags  *class* ) -1)
                        (field "readPoint" long (accessflags  *class* ) -1)
                        (field "startPoint" long (accessflags  *class* ) -1)
                        (field "startTime" long (accessflags  *class* ) -1)
                        (field "retryex" (class "clojure.lang.LockingTransaction$RetryEx") (accessflags  *class*  *final* ) -1)
                        (field "actions" (class "java.util.ArrayList") (accessflags  *class*  *final* ) -1)
                        (field "vals" (class "java.util.HashMap") (accessflags  *class*  *final* ) -1)
                        (field "sets" (class "java.util.HashSet") (accessflags  *class*  *final* ) -1)
                        (field "commutes" (class "java.util.TreeMap") (accessflags  *class*  *final* ) -1)
                        (field "ensures" (class "java.util.HashSet") (accessflags  *class*  *final* ) -1))
            (methods
                        (method "<init>"
                              (parameters )
                              (returntype . void)
                              (accessflags  *class*  *public* )
                              (code
                                   (max_stack . 3) (max_locals . 1) (code_length . 71)
                                   (parsedcode
                                      (0 (aload_0))
                                      (1 (invokespecial
					(methodCP "<init>" "java.lang.Object" () void)))
                                      (4 (aload_0))
                                      (5 (new (class "clojure.lang.LockingTransaction$RetryEx")))
                                      (8 (dup))
                                      (9 (invokespecial
					(methodCP "<init>" "clojure.lang.LockingTransaction$RetryEx" () void)))
                                      (12 (putfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx"))))
                                      (15 (aload_0))
                                      (16 (new (class "java.util.ArrayList")))
                                      (19 (dup))
                                      (20 (invokespecial
					(methodCP "<init>" "java.util.ArrayList" () void)))
                                      (23 (putfield (fieldCP "actions" "clojure.lang.LockingTransaction" (class "java.util.ArrayList"))))
                                      (26 (aload_0))
                                      (27 (new (class "java.util.HashMap")))
                                      (30 (dup))
                                      (31 (invokespecial
					(methodCP "<init>" "java.util.HashMap" () void)))
                                      (34 (putfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap"))))
                                      (37 (aload_0))
                                      (38 (new (class "java.util.HashSet")))
                                      (41 (dup))
                                      (42 (invokespecial
					(methodCP "<init>" "java.util.HashSet" () void)))
                                      (45 (putfield (fieldCP "sets" "clojure.lang.LockingTransaction" (class "java.util.HashSet"))))
                                      (48 (aload_0))
                                      (49 (new (class "java.util.TreeMap")))
                                      (52 (dup))
                                      (53 (invokespecial
					(methodCP "<init>" "java.util.TreeMap" () void)))
                                      (56 (putfield (fieldCP "commutes" "clojure.lang.LockingTransaction" (class "java.util.TreeMap"))))
                                      (59 (aload_0))
                                      (60 (new (class "java.util.HashSet")))
                                      (63 (dup))
                                      (64 (invokespecial
					(methodCP "<init>" "java.util.HashSet" () void)))
                                      (67 (putfield (fieldCP "ensures" "clojure.lang.LockingTransaction" (class "java.util.HashSet"))))
                                      (70 (return))
                                      (endofcode 71))
                                   (Exceptions )
                                   (StackMap )))
                        (method "getReadPoint"
                              (parameters )
                              (returntype . void)
                              (accessflags  *class* )
                              (code
                                   (max_stack . 3) (max_locals . 1) (code_length . 11)
                                   (parsedcode
                                      (0 (aload_0))
                                      (1 (getstatic (fieldCP "lastPoint" "clojure.lang.LockingTransaction" (class "java.util.concurrent.atomic.AtomicLong"))))
                                      (4 (invokevirtual
					(methodCP "incrementAndGet" "java.util.concurrent.atomic.AtomicLong" () long)))
                                      (7 (putfield (fieldCP "readPoint" "clojure.lang.LockingTransaction" long)))
                                      (10 (return))
                                      (endofcode 11))
                                   (Exceptions )
                                   (StackMap )))
                        (method "getCommitPoint"
                              (parameters )
                              (returntype . long)
                              (accessflags  *class* )
                              (code
                                   (max_stack . 2) (max_locals . 1) (code_length . 7)
                                   (parsedcode
                                      (0 (getstatic (fieldCP "lastPoint" "clojure.lang.LockingTransaction" (class "java.util.concurrent.atomic.AtomicLong"))))
                                      (3 (invokevirtual
					(methodCP "incrementAndGet" "java.util.concurrent.atomic.AtomicLong" () long)))
                                      (6 (lreturn))
                                      (endofcode 7))
                                   (Exceptions )
                                   (StackMap )))
                        (method "stop"
                              (parameters int)
                              (returntype . void)
                              (accessflags  *class* )
                              (code
                                   (max_stack . 2) (max_locals . 4) (code_length . 72)
                                   (parsedcode
                                      (0 (aload_0)) 
                                      (1 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (4 (ifnull 71)) ;;to TAG_0
                                      (7 (aload_0)) 
                                      (8 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (11 (dup)) 
                                      (12 (astore_2)) 
                                      (13 (monitorenter)) 
                                      (14 (aload_0)) ;;at TAG_2
                                      (15 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (18 (getfield (fieldCP "status" "clojure.lang.LockingTransaction$Info" (class "java.util.concurrent.atomic.AtomicInteger")))) 
                                      (21 (iload_1)) 
                                      (22 (invokevirtual (methodCP "set" "java.util.concurrent.atomic.AtomicInteger" (int) void))) 
                                      (25 (aload_0)) 
                                      (26 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (29 (getfield (fieldCP "latch" "clojure.lang.LockingTransaction$Info" (class "java.util.concurrent.CountDownLatch")))) 
                                      (32 (invokevirtual (methodCP "countDown" "java.util.concurrent.CountDownLatch" () void))) 
                                      (35 (aload_2)) 
                                      (36 (monitorexit)) 
                                      (37 (goto 45)) ;;to TAG_1;;at TAG_3
                                      (40 (astore_3)) ;;at TAG_4
                                      (41 (aload_2)) 
                                      (42 (monitorexit)) 
                                      (43 (aload_3)) ;;at TAG_5
                                      (44 (athrow)) 
                                      (45 (aload_0)) ;;at TAG_1
                                      (46 (aconst_null)) 
                                      (47 (putfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (50 (aload_0)) 
                                      (51 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (54 (invokevirtual (methodCP "clear" "java.util.HashMap" () void))) 
                                      (57 (aload_0)) 
                                      (58 (getfield (fieldCP "sets" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (61 (invokevirtual (methodCP "clear" "java.util.HashSet" () void))) 
                                      (64 (aload_0)) 
                                      (65 (getfield (fieldCP "commutes" "clojure.lang.LockingTransaction" (class "java.util.TreeMap")))) 
                                      (68 (invokevirtual (methodCP "clear" "java.util.TreeMap" () void))) 
                                      (71 (return)) ;;at TAG_0
                                      (endofcode 72))
                                   (Exceptions 
                                     (handler 14 37  40 (class "java.lang.Throwable"))
                                     (handler 40 43  40 (class "java.lang.Throwable")))
                                   (StackMap )))
                        (method "tryWriteLock"
                              (parameters (class "clojure.lang.Ref"))
                              (returntype . void)
                              (accessflags  *class* )
                              (code
                                   (max_stack . 4) (max_locals . 3) (code_length . 34)
                                   (parsedcode
                                      (0 (aload_1)) ;;at TAG_2
                                      (1 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (4 (invokevirtual (methodCP "writeLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock")))) 
                                      (7 (ldc2_w 8)) ;; LONG:: "100"
                                      (10 (getstatic (fieldCP "MILLISECONDS" "java.util.concurrent.TimeUnit" (class "java.util.concurrent.TimeUnit")))) 
                                      (13 (invokevirtual (methodCP "tryLock" "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock" (long (class "java.util.concurrent.TimeUnit")) boolean))) 
                                      (16 (ifne 24)) ;;to TAG_0
                                      (19 (aload_0)) 
                                      (20 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (23 (athrow)) 
                                      (24 (goto 33)) ;;to TAG_1;;at TAG_0
                                      (27 (astore_2)) ;;at TAG_3
                                      (28 (aload_0)) 
                                      (29 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (32 (athrow)) 
                                      (33 (return)) ;;at TAG_1
                                      (endofcode 34))
                                   (Exceptions 
                                     (handler 0 24  27 (class "java.lang.InterruptedException")))
                                   (StackMap )))
                        (method "lock"
                              (parameters (class "clojure.lang.Ref"))
                              (returntype . (class "java.lang.Object"))
                              (accessflags  *class* )
                              (code
                                   (max_stack . 4) (max_locals . 6) (code_length . 173)
                                   (parsedcode
                                      (0 (aload_0)) 
                                      (1 (aload_1)) 
                                      (2 (invokespecial (methodCP "releaseIfEnsured" "clojure.lang.LockingTransaction" ((class "clojure.lang.Ref")) void))) 
                                      (5 (iconst_1)) 
                                      (6 (istore_2)) 
                                      (7 (aload_0)) ;;at TAG_7
                                      (8 (aload_1)) 
                                      (9 (invokevirtual (methodCP "tryWriteLock" "clojure.lang.LockingTransaction" ((class "clojure.lang.Ref")) void))) 
                                      (12 (iconst_0)) 
                                      (13 (istore_2)) 
                                      (14 (aload_1)) 
                                      (15 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (18 (ifnull 41)) ;;to TAG_0
                                      (21 (aload_1)) 
                                      (22 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (25 (getfield (fieldCP "point" "clojure.lang.Ref$TVal" long))) 
                                      (28 (aload_0)) 
                                      (29 (getfield (fieldCP "readPoint" "clojure.lang.LockingTransaction" long))) 
                                      (32 (lcmp)) 
                                      (33 (ifle 41)) ;;to TAG_0
                                      (36 (aload_0)) 
                                      (37 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (40 (athrow)) 
                                      (41 (aload_1)) ;;at TAG_0
                                      (42 (getfield (fieldCP "tinfo" "clojure.lang.Ref" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (45 (astore_3)) 
                                      (46 (aload_3)) 
                                      (47 (ifnull 109))  ;;to TAG_1
                                      (50 (aload_3)) 
                                      (51 (aload_0)) 
                                      (52 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (55 (if_acmpeq 109))  ;;to TAG_1
                                      (58 (aload_3)) 
                                      (59 (invokevirtual (methodCP "running" "clojure.lang.LockingTransaction$Info" () boolean))) 
                                      (62 (ifeq 109))  ;;to TAG_1
                                      (65 (aload_0)) 
                                      (66 (aload_3)) 
                                      (67 (invokespecial (methodCP "barge" "clojure.lang.LockingTransaction" ((class "clojure.lang.LockingTransaction$Info")) boolean))) 
                                      (70 (ifne 109))  ;;to TAG_1
                                      (73 (aload_1)) 
                                      (74 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (77 (invokevirtual (methodCP "writeLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock")))) 
                                      (80 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock" () void))) 
                                      (83 (iconst_1)) 
                                      (84 (istore_2)) 
                                      (85 (aload_0)) 
                                      (86 (aload_3)) 
                                      (87 (invokespecial (methodCP "blockAndBail" "clojure.lang.LockingTransaction" ((class "clojure.lang.LockingTransaction$Info")) (class "java.lang.Object")))) 
                                      (90 (astore 4)) 
                                      (92 (iload_2)) ;;at TAG_8
                                      (93 (ifne 106)) ;;to TAG_2
                                      (96 (aload_1)) 
                                      (97 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (100 (invokevirtual (methodCP "writeLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock")))) 
                                      (103 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock" () void))) 
                                      (106 (aload 4)) ;;at TAG_2
                                      (108 (areturn)) 
                                      (109 (aload_1)) ;;at TAG_1
                                      (110 (aload_0)) 
                                      (111 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (114 (putfield (fieldCP "tinfo" "clojure.lang.Ref" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (117 (aload_1)) 
                                      (118 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (121 (ifnonnull 128)) ;;to TAG_3
                                      (124 (aconst_null)) 
                                      (125 (goto 135)) ;;to TAG_4
                                      (128 (aload_1)) ;;at TAG_3
                                      (129 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (132 (getfield (fieldCP "val" "clojure.lang.Ref$TVal" (class "java.lang.Object")))) 
                                      (135 (astore 4)) ;;at TAG_4
                                      (137 (iload_2)) ;;at TAG_10
                                      (138 (ifne 151)) ;;to TAG_5
                                      (141 (aload_1)) 
                                      (142 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (145 (invokevirtual (methodCP "writeLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock")))) 
                                      (148 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock" () void))) 
                                      (151 (aload 4)) ;;at TAG_5
                                      (153 (areturn)) 
                                      (154 (astore 5)) ;;at TAG_9
                                      (156 (iload_2)) ;;at TAG_11
                                      (157 (ifne 170)) ;;to TAG_6
                                      (160 (aload_1)) 
                                      (161 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (164 (invokevirtual (methodCP "writeLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock")))) 
                                      (167 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock" () void))) 
                                      (170 (aload 5)) ;;at TAG_6
                                      (172 (athrow)) 
                                      (endofcode 173))
                                   (Exceptions 
                                     (handler 7 92  154 (class "java.lang.Throwable"))
                                     (handler 109 137  154 (class "java.lang.Throwable"))
                                     (handler 154 156  154 (class "java.lang.Throwable")))
                                   (StackMap )))
                        (method "blockAndBail"
                              (parameters (class "clojure.lang.LockingTransaction$Info"))
                              (returntype . (class "java.lang.Object"))
                              (accessflags  *class*  *private* )
                              (code
                                   (max_stack . 4) (max_locals . 3) (code_length . 28)
                                   (parsedcode
                                      (0 (aload_0)) 
                                      (1 (iconst_2)) 
                                      (2 (invokevirtual (methodCP "stop" "clojure.lang.LockingTransaction" (int) void))) 
                                      (5 (aload_1)) ;;at TAG_1
                                      (6 (getfield (fieldCP "latch" "clojure.lang.LockingTransaction$Info" (class "java.util.concurrent.CountDownLatch")))) 
                                      (9 (ldc2_w 8)) ;; LONG:: "100"
                                      (12 (getstatic (fieldCP "MILLISECONDS" "java.util.concurrent.TimeUnit" (class "java.util.concurrent.TimeUnit")))) 
                                      (15 (invokevirtual (methodCP "await" "java.util.concurrent.CountDownLatch" (long (class "java.util.concurrent.TimeUnit")) boolean))) 
                                      (18 (pop)) 
                                      (19 (goto 23)) ;;to TAG_0;;at TAG_2
                                      (22 (astore_2)) ;;at TAG_3
                                      (23 (aload_0)) ;;at TAG_0
                                      (24 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (27 (athrow)) 
                                      (endofcode 28))
                                   (Exceptions 
                                     (handler 5 19  22 (class "java.lang.InterruptedException")))
                                   (StackMap )))
                        (method "releaseIfEnsured"
                              (parameters (class "clojure.lang.Ref"))
                              (returntype . void)
                              (accessflags  *class*  *private* )
                              (code
                                   (max_stack . 2) (max_locals . 2) (code_length . 31)
                                   (parsedcode
                                      (0 (aload_0)) 
                                      (1 (getfield (fieldCP "ensures" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (4 (aload_1)) 
                                      (5 (invokevirtual (methodCP "contains" "java.util.HashSet" ((class "java.lang.Object")) boolean))) 
                                      (8 (ifeq 30))  ;;to TAG_0
                                      (11 (aload_0)) 
                                      (12 (getfield (fieldCP "ensures" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (15 (aload_1)) 
                                      (16 (invokevirtual (methodCP "remove" "java.util.HashSet" ((class "java.lang.Object")) boolean))) 
                                      (19 (pop)) 
                                      (20 (aload_1)) 
                                      (21 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (24 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (27 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (30 (return)) ;;at TAG_0
                                      (endofcode 31))
                                   (Exceptions )
                                   (StackMap )))
                        (method "abort"
                              (parameters )
                              (returntype . void)
                              (accessflags  *class* )
                              (code
                                   (max_stack . 2) (max_locals . 1) (code_length . 13)
                                   (parsedcode
                                      (0 (aload_0))
                                      (1 (iconst_3))
                                      (2 (invokevirtual
					(methodCP "stop" "clojure.lang.LockingTransaction" (int) void)))
                                      (5 (new (class "clojure.lang.LockingTransaction$AbortException")))
                                      (8 (dup))
                                      (9 (invokespecial
					(methodCP "<init>" "clojure.lang.LockingTransaction$AbortException" () void)))
                                      (12 (athrow))
                                      (endofcode 13))
                                   (Exceptions )
                                   (StackMap )))
                        (method "bargeTimeElapsed"
                              (parameters )
                              (returntype . boolean)
                              (accessflags  *class*  *private* )
                              (code
                                   (max_stack . 4) (max_locals . 1) (code_length . 21)
                                   (parsedcode
                                      (0 (invokestatic (methodCP "nanoTime" "java.lang.System" () long))) 
                                      (3 (aload_0)) 
                                      (4 (getfield (fieldCP "startTime" "clojure.lang.LockingTransaction" long))) 
                                      (7 (lsub)) 
                                      (8 (ldc2_w 2)) ;; LONG:: "10000000"
                                      (11 (lcmp)) 
                                      (12 (ifle 19))  ;;to TAG_0
                                      (15 (iconst_1)) 
                                      (16 (goto 20)) ;;to TAG_1
                                      (19 (iconst_0)) ;;at TAG_0
                                      (20 (ireturn)) ;;at TAG_1
                                      (endofcode 21))
                                   (Exceptions )
                                   (StackMap )))
                        (method "barge"
                              (parameters (class "clojure.lang.LockingTransaction$Info"))
                              (returntype . boolean)
                              (accessflags  *class*  *private* )
                              (code
                                   (max_stack . 4) (max_locals . 3) (code_length . 44)
                                   (parsedcode
                                      (0 (iconst_0)) 
                                      (1 (istore_2)) 
                                      (2 (aload_0)) 
                                      (3 (invokespecial (methodCP "bargeTimeElapsed" "clojure.lang.LockingTransaction" () boolean))) 
                                      (6 (ifeq 42))  ;;to TAG_0
                                      (9 (aload_0)) 
                                      (10 (getfield (fieldCP "startPoint" "clojure.lang.LockingTransaction" long))) 
                                      (13 (aload_1)) 
                                      (14 (getfield (fieldCP "startPoint" "clojure.lang.LockingTransaction$Info" long))) 
                                      (17 (lcmp)) 
                                      (18 (ifge 42))  ;;to TAG_0
                                      (21 (aload_1)) 
                                      (22 (getfield (fieldCP "status" "clojure.lang.LockingTransaction$Info" (class "java.util.concurrent.atomic.AtomicInteger")))) 
                                      (25 (iconst_0)) 
                                      (26 (iconst_3)) 
                                      (27 (invokevirtual (methodCP "compareAndSet" "java.util.concurrent.atomic.AtomicInteger" (int int) boolean))) 
                                      (30 (istore_2)) 
                                      (31 (iload_2)) 
                                      (32 (ifeq 42))  ;;to TAG_0
                                      (35 (aload_1)) 
                                      (36 (getfield (fieldCP "latch" "clojure.lang.LockingTransaction$Info" (class "java.util.concurrent.CountDownLatch")))) 
                                      (39 (invokevirtual (methodCP "countDown" "java.util.concurrent.CountDownLatch" () void))) 
                                      (42 (iload_2)) ;;at TAG_0
                                      (43 (ireturn)) 
                                      (endofcode 44))
                                   (Exceptions )
                                   (StackMap )))
                        (method "getEx"
                              (parameters )
                              (returntype . (class "clojure.lang.LockingTransaction"))
                              (accessflags  *class*  *static* )
                              (code
                                   (max_stack . 3) (max_locals . 1) (code_length . 33)
                                   (parsedcode
                                      (0 (getstatic (fieldCP "transaction" "clojure.lang.LockingTransaction" (class "java.lang.ThreadLocal")))) 
                                      (3 (invokevirtual (methodCP "get" "java.lang.ThreadLocal" () (class "java.lang.Object")))) 
                                      (6 (checkcast (class "clojure.lang.LockingTransaction"))) 
                                      (9 (astore_0)) 
                                      (10 (aload_0)) 
                                      (11 (ifnull 21))  ;;to TAG_0
                                      (14 (aload_0)) 
                                      (15 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (18 (ifnonnull 31)) ;;to TAG_1
                                      (21 (new (class "java.lang.IllegalStateException"))) ;;at TAG_0
                                      (24 (dup)) 
                                      (25 (ldc 9)) ;;STRING:: "No transaction running"
                                      (27 (invokespecial (methodCP "<init>" "java.lang.IllegalStateException" ((class "java.lang.String")) void))) 
                                      (30 (athrow)) 
                                      (31 (aload_0)) ;;at TAG_1
                                      (32 (areturn)) 
                                      (endofcode 33))
                                   (Exceptions )
                                   (StackMap )))
                        (method "isRunning"
                              (parameters )
                              (returntype . boolean)
                              (accessflags  *class*  *public*  *static* )
                              (code
                                   (max_stack . 1) (max_locals . 0) (code_length . 12)
                                   (parsedcode
                                      (0 (invokestatic (methodCP "getRunning" "clojure.lang.LockingTransaction" () (class "clojure.lang.LockingTransaction")))) 
                                      (3 (ifnull 10))  ;;to TAG_0
                                      (6 (iconst_1)) 
                                      (7 (goto 11)) ;;to TAG_1
                                      (10 (iconst_0)) ;;at TAG_0
                                      (11 (ireturn)) ;;at TAG_1
                                      (endofcode 12))
                                   (Exceptions )
                                   (StackMap )))
                        (method "getRunning"
                              (parameters )
                              (returntype . (class "clojure.lang.LockingTransaction"))
                              (accessflags  *class*  *static* )
                              (code
                                   (max_stack . 1) (max_locals . 1) (code_length . 25)
                                   (parsedcode
                                      (0 (getstatic (fieldCP "transaction" "clojure.lang.LockingTransaction" (class "java.lang.ThreadLocal")))) 
                                      (3 (invokevirtual (methodCP "get" "java.lang.ThreadLocal" () (class "java.lang.Object")))) 
                                      (6 (checkcast (class "clojure.lang.LockingTransaction"))) 
                                      (9 (astore_0)) 
                                      (10 (aload_0)) 
                                      (11 (ifnull 21))  ;;to TAG_0
                                      (14 (aload_0)) 
                                      (15 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (18 (ifnonnull 23)) ;;to TAG_1
                                      (21 (aconst_null)) ;;at TAG_0
                                      (22 (areturn)) 
                                      (23 (aload_0)) ;;at TAG_1
                                      (24 (areturn)) 
                                      (endofcode 25))
                                   (Exceptions )
                                   (StackMap )))
                        (method "runInTransaction"
                              (parameters (class "java.util.concurrent.Callable"))
                              (returntype . (class "java.lang.Object"))
                              (accessflags  *class*  *public*  *static* )
                              (code
                                   (max_stack . 3) (max_locals . 2) (code_length . 49)
                                   (parsedcode
                                      (0 (getstatic (fieldCP "transaction" "clojure.lang.LockingTransaction" (class "java.lang.ThreadLocal")))) 
                                      (3 (invokevirtual (methodCP "get" "java.lang.ThreadLocal" () (class "java.lang.Object")))) 
                                      (6 (checkcast (class "clojure.lang.LockingTransaction"))) 
                                      (9 (astore_1)) 
                                      (10 (aload_1)) 
                                      (11 (ifnonnull 29))  ;;to TAG_0
                                      (14 (getstatic (fieldCP "transaction" "clojure.lang.LockingTransaction" (class "java.lang.ThreadLocal")))) 
                                      (17 (new (class "clojure.lang.LockingTransaction"))) 
                                      (20 (dup)) 
                                      (21 (invokespecial (methodCP "<init>" "clojure.lang.LockingTransaction" () void))) 
                                      (24 (dup)) 
                                      (25 (astore_1)) 
                                      (26 (invokevirtual (methodCP "set" "java.lang.ThreadLocal" ((class "java.lang.Object")) void))) 
                                      (29 (aload_1)) ;;at TAG_0
                                      (30 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (33 (ifnull 43)) ;;to TAG_1
                                      (36 (aload_0)) 
                                      (37 (invokeinterface (methodCP "call" "java.util.concurrent.Callable" () (class "java.lang.Object")) 1)) 
                                      (42 (areturn)) 
                                      (43 (aload_1)) ;;at TAG_1
                                      (44 (aload_0)) 
                                      (45 (invokevirtual (methodCP "run" "clojure.lang.LockingTransaction" ((class "java.util.concurrent.Callable")) (class "java.lang.Object")))) 
                                      (48 (areturn)) 
                                      (endofcode 49))
                                   (Exceptions )
                                   (StackMap )))
                        (method "run"
                              (parameters (class "java.util.concurrent.Callable"))
                              (returntype . (class "java.lang.Object"))
                              (accessflags  *class* )
                              (code
                                   (max_stack . 9) (max_locals . 23) (code_length . 1059)
                                   (parsedcode
                                      (0 (iconst_0)) 
                                      (1 (istore_2)) 
                                      (2 (aconst_null)) 
                                      (3 (astore_3)) 
                                      (4 (new (class "java.util.ArrayList"))) 
                                      (7 (dup)) 
                                      (8 (invokespecial (methodCP "<init>" "java.util.ArrayList" () void))) 
                                      (11 (astore 4)) 
                                      (13 (new (class "java.util.ArrayList"))) 
                                      (16 (dup)) 
                                      (17 (invokespecial (methodCP "<init>" "java.util.ArrayList" () void))) 
                                      (20 (astore 5)) 
                                      (22 (iconst_0)) 
                                      (23 (istore 6)) 
                                      (25 (iload_2)) ;;at TAG_40
                                      (26 (ifne 1047))  ;;to TAG_0
                                      (29 (iload 6)) 
                                      (31 (sipush 10000)) 
                                      (34 (if_icmpge 1047))  ;;to TAG_0
                                      (37 (aload_0)) ;;at TAG_42
                                      (38 (invokevirtual (methodCP "getReadPoint" "clojure.lang.LockingTransaction" () void))) 
                                      (41 (iload 6)) 
                                      (43 (ifne 61)) ;;to TAG_1
                                      (46 (aload_0)) 
                                      (47 (aload_0)) 
                                      (48 (getfield (fieldCP "readPoint" "clojure.lang.LockingTransaction" long))) 
                                      (51 (putfield (fieldCP "startPoint" "clojure.lang.LockingTransaction" long))) 
                                      (54 (aload_0)) 
                                      (55 (invokestatic (methodCP "nanoTime" "java.lang.System" () long))) 
                                      (58 (putfield (fieldCP "startTime" "clojure.lang.LockingTransaction" long))) 
                                      (61 (aload_0)) ;;at TAG_1
                                      (62 (new (class "clojure.lang.LockingTransaction$Info"))) 
                                      (65 (dup)) 
                                      (66 (iconst_0)) 
                                      (67 (aload_0)) 
                                      (68 (getfield (fieldCP "startPoint" "clojure.lang.LockingTransaction" long))) 
                                      (71 (invokespecial (methodCP "<init>" "clojure.lang.LockingTransaction$Info" (int long) void))) 
                                      (74 (putfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (77 (aload_1)) 
                                      (78 (invokeinterface (methodCP "call" "java.util.concurrent.Callable" () (class "java.lang.Object")) 1)) 
                                      (83 (astore_3)) 
                                      (84 (aload_0)) 
                                      (85 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (88 (getfield (fieldCP "status" "clojure.lang.LockingTransaction$Info" (class "java.util.concurrent.atomic.AtomicInteger")))) 
                                      (91 (iconst_0)) 
                                      (92 (iconst_1)) 
                                      (93 (invokevirtual (methodCP "compareAndSet" "java.util.concurrent.atomic.AtomicInteger" (int int) boolean))) 
                                      (96 (ifeq 783)) ;;to TAG_2
                                      (99 (aload_0)) 
                                      (100 (getfield (fieldCP "commutes" "clojure.lang.LockingTransaction" (class "java.util.TreeMap")))) 
                                      (103 (invokevirtual (methodCP "entrySet" "java.util.TreeMap" () (class "java.util.Set")))) 
                                      (106 (invokeinterface (methodCP "iterator" "java.util.Set" () (class "java.util.Iterator")) 1)) 
                                      (111 (astore 7)) 
                                      (113 (aload 7)) ;;at TAG_5
                                      (115 (invokeinterface (methodCP "hasNext" "java.util.Iterator" () boolean) 1)) 
                                      (120 (ifeq 384)) ;;to TAG_3
                                      (123 (aload 7)) 
                                      (125 (invokeinterface (methodCP "next" "java.util.Iterator" () (class "java.lang.Object")) 1)) 
                                      (130 (checkcast (class "java.util.Map$Entry"))) 
                                      (133 (astore 8)) 
                                      (135 (aload 8)) 
                                      (137 (invokeinterface (methodCP "getKey" "java.util.Map$Entry" () (class "java.lang.Object")) 1)) 
                                      (142 (checkcast (class "clojure.lang.Ref"))) 
                                      (145 (astore 9)) 
                                      (147 (aload_0)) 
                                      (148 (getfield (fieldCP "sets" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (151 (aload 9)) 
                                      (153 (invokevirtual (methodCP "contains" "java.util.HashSet" ((class "java.lang.Object")) boolean))) 
                                      (156 (ifeq 162)) ;;to TAG_4
                                      (159 (goto 113)) ;;to TAG_5
                                      (162 (aload_0)) ;;at TAG_4
                                      (163 (getfield (fieldCP "ensures" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (166 (aload 9)) 
                                      (168 (invokevirtual (methodCP "contains" "java.util.HashSet" ((class "java.lang.Object")) boolean))) 
                                      (171 (istore 10)) 
                                      (173 (aload_0)) 
                                      (174 (aload 9)) 
                                      (176 (invokespecial (methodCP "releaseIfEnsured" "clojure.lang.LockingTransaction" ((class "clojure.lang.Ref")) void))) 
                                      (179 (aload_0)) 
                                      (180 (aload 9)) 
                                      (182 (invokevirtual (methodCP "tryWriteLock" "clojure.lang.LockingTransaction" ((class "clojure.lang.Ref")) void))) 
                                      (185 (aload 4)) 
                                      (187 (aload 9)) 
                                      (189 (invokevirtual (methodCP "add" "java.util.ArrayList" ((class "java.lang.Object")) boolean))) 
                                      (192 (pop)) 
                                      (193 (iload 10)) 
                                      (195 (ifeq 227)) ;;to TAG_6
                                      (198 (aload 9)) 
                                      (200 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (203 (ifnull 227)) ;;to TAG_6
                                      (206 (aload 9)) 
                                      (208 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (211 (getfield (fieldCP "point" "clojure.lang.Ref$TVal" long))) 
                                      (214 (aload_0)) 
                                      (215 (getfield (fieldCP "readPoint" "clojure.lang.LockingTransaction" long))) 
                                      (218 (lcmp)) 
                                      (219 (ifle 227)) ;;to TAG_6
                                      (222 (aload_0)) 
                                      (223 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (226 (athrow)) 
                                      (227 (aload 9)) ;;at TAG_6
                                      (229 (getfield (fieldCP "tinfo" "clojure.lang.Ref" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (232 (astore 11)) 
                                      (234 (aload 11)) 
                                      (236 (ifnull 270)) ;;to TAG_7
                                      (239 (aload 11)) 
                                      (241 (aload_0)) 
                                      (242 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (245 (if_acmpeq 270)) ;;to TAG_7
                                      (248 (aload 11)) 
                                      (250 (invokevirtual (methodCP "running" "clojure.lang.LockingTransaction$Info" () boolean))) 
                                      (253 (ifeq 270)) ;;to TAG_7
                                      (256 (aload_0)) 
                                      (257 (aload 11)) 
                                      (259 (invokespecial (methodCP "barge" "clojure.lang.LockingTransaction" ((class "clojure.lang.LockingTransaction$Info")) boolean))) 
                                      (262 (ifne 270)) ;;to TAG_7
                                      (265 (aload_0)) 
                                      (266 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (269 (athrow)) 
                                      (270 (aload 9)) ;;at TAG_7
                                      (272 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (275 (ifnonnull 282)) ;;to TAG_8
                                      (278 (aconst_null)) 
                                      (279 (goto 290)) ;;to TAG_9
                                      (282 (aload 9)) ;;at TAG_8
                                      (284 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (287 (getfield (fieldCP "val" "clojure.lang.Ref$TVal" (class "java.lang.Object")))) 
                                      (290 (astore 12)) ;;at TAG_9
                                      (292 (aload_0)) 
                                      (293 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (296 (aload 9)) 
                                      (298 (aload 12)) 
                                      (300 (invokevirtual (methodCP "put" "java.util.HashMap" ((class "java.lang.Object") (class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (303 (pop)) 
                                      (304 (aload 8)) 
                                      (306 (invokeinterface (methodCP "getValue" "java.util.Map$Entry" () (class "java.lang.Object")) 1)) 
                                      (311 (checkcast (class "java.util.ArrayList"))) 
                                      (314 (invokevirtual (methodCP "iterator" "java.util.ArrayList" () (class "java.util.Iterator")))) 
                                      (317 (astore 13)) 
                                      (319 (aload 13)) ;;at TAG_11
                                      (321 (invokeinterface (methodCP "hasNext" "java.util.Iterator" () boolean) 1)) 
                                      (326 (ifeq 381)) ;;to TAG_10
                                      (329 (aload 13)) 
                                      (331 (invokeinterface (methodCP "next" "java.util.Iterator" () (class "java.lang.Object")) 1)) 
                                      (336 (checkcast (class "clojure.lang.LockingTransaction$CFn"))) 
                                      (339 (astore 14)) 
                                      (341 (aload_0)) 
                                      (342 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (345 (aload 9)) 
                                      (347 (aload 14)) 
                                      (349 (getfield (fieldCP "fn" "clojure.lang.LockingTransaction$CFn" (class "clojure.lang.IFn")))) 
                                      (352 (aload_0)) 
                                      (353 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (356 (aload 9)) 
                                      (358 (invokevirtual (methodCP "get" "java.util.HashMap" ((class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (361 (aload 14)) 
                                      (363 (getfield (fieldCP "args" "clojure.lang.LockingTransaction$CFn" (class "clojure.lang.ISeq")))) 
                                      (366 (invokestatic (methodCP "cons" "clojure.lang.RT" ((class "java.lang.Object") (class "java.lang.Object")) (class "clojure.lang.ISeq")))) 
                                      (369 (invokeinterface (methodCP "applyTo" "clojure.lang.IFn" ((class "clojure.lang.ISeq")) (class "java.lang.Object")) 2)) 
                                      (374 (invokevirtual (methodCP "put" "java.util.HashMap" ((class "java.lang.Object") (class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (377 (pop)) 
                                      (378 (goto 319)) ;;to TAG_11
                                      (381 (goto 113)) ;;to TAG_5;;at TAG_10
                                      (384 (aload_0)) ;;at TAG_3
                                      (385 (getfield (fieldCP "sets" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (388 (invokevirtual (methodCP "iterator" "java.util.HashSet" () (class "java.util.Iterator")))) 
                                      (391 (astore 7)) 
                                      (393 (aload 7)) ;;at TAG_13
                                      (395 (invokeinterface (methodCP "hasNext" "java.util.Iterator" () boolean) 1)) 
                                      (400 (ifeq 432)) ;;to TAG_12
                                      (403 (aload 7)) 
                                      (405 (invokeinterface (methodCP "next" "java.util.Iterator" () (class "java.lang.Object")) 1)) 
                                      (410 (checkcast (class "clojure.lang.Ref"))) 
                                      (413 (astore 8)) 
                                      (415 (aload_0)) 
                                      (416 (aload 8)) 
                                      (418 (invokevirtual (methodCP "tryWriteLock" "clojure.lang.LockingTransaction" ((class "clojure.lang.Ref")) void))) 
                                      (421 (aload 4)) 
                                      (423 (aload 8)) 
                                      (425 (invokevirtual (methodCP "add" "java.util.ArrayList" ((class "java.lang.Object")) boolean))) 
                                      (428 (pop)) 
                                      (429 (goto 393)) ;;to TAG_13
                                      (432 (aload_0)) ;;at TAG_12
                                      (433 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (436 (invokevirtual (methodCP "entrySet" "java.util.HashMap" () (class "java.util.Set")))) 
                                      (439 (invokeinterface (methodCP "iterator" "java.util.Set" () (class "java.util.Iterator")) 1)) 
                                      (444 (astore 7)) 
                                      (446 (aload 7)) ;;at TAG_15
                                      (448 (invokeinterface (methodCP "hasNext" "java.util.Iterator" () boolean) 1)) 
                                      (453 (ifeq 500)) ;;to TAG_14
                                      (456 (aload 7)) 
                                      (458 (invokeinterface (methodCP "next" "java.util.Iterator" () (class "java.lang.Object")) 1)) 
                                      (463 (checkcast (class "java.util.Map$Entry"))) 
                                      (466 (astore 8)) 
                                      (468 (aload 8)) 
                                      (470 (invokeinterface (methodCP "getKey" "java.util.Map$Entry" () (class "java.lang.Object")) 1)) 
                                      (475 (checkcast (class "clojure.lang.Ref"))) 
                                      (478 (astore 9)) 
                                      (480 (aload 9)) 
                                      (482 (aload 9)) 
                                      (484 (invokevirtual (methodCP "getValidator" "clojure.lang.Ref" () (class "clojure.lang.IFn")))) 
                                      (487 (aload 8)) 
                                      (489 (invokeinterface (methodCP "getValue" "java.util.Map$Entry" () (class "java.lang.Object")) 1)) 
                                      (494 (invokevirtual (methodCP "validate" "clojure.lang.Ref" ((class "clojure.lang.IFn") (class "java.lang.Object")) void))) 
                                      (497 (goto 446)) ;;to TAG_15
                                      (500 (invokestatic (methodCP "currentTimeMillis" "java.lang.System" () long))) ;;at TAG_14
                                      (503 (lstore 7)) 
                                      (505 (aload_0)) 
                                      (506 (invokevirtual (methodCP "getCommitPoint" "clojure.lang.LockingTransaction" () long))) 
                                      (509 (lstore 9)) 
                                      (511 (aload_0)) 
                                      (512 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (515 (invokevirtual (methodCP "entrySet" "java.util.HashMap" () (class "java.util.Set")))) 
                                      (518 (invokeinterface (methodCP "iterator" "java.util.Set" () (class "java.util.Iterator")) 1)) 
                                      (523 (astore 11)) 
                                      (525 (aload 11)) ;;at TAG_25
                                      (527 (invokeinterface (methodCP "hasNext" "java.util.Iterator" () boolean) 1)) 
                                      (532 (ifeq 770)) ;;to TAG_16
                                      (535 (aload 11)) 
                                      (537 (invokeinterface (methodCP "next" "java.util.Iterator" () (class "java.lang.Object")) 1)) 
                                      (542 (checkcast (class "java.util.Map$Entry"))) 
                                      (545 (astore 12)) 
                                      (547 (aload 12)) 
                                      (549 (invokeinterface (methodCP "getKey" "java.util.Map$Entry" () (class "java.lang.Object")) 1)) 
                                      (554 (checkcast (class "clojure.lang.Ref"))) 
                                      (557 (astore 13)) 
                                      (559 (aload 13)) 
                                      (561 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (564 (ifnonnull 571)) ;;to TAG_17
                                      (567 (aconst_null)) 
                                      (568 (goto 579)) ;;to TAG_18
                                      (571 (aload 13)) ;;at TAG_17
                                      (573 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (576 (getfield (fieldCP "val" "clojure.lang.Ref$TVal" (class "java.lang.Object")))) 
                                      (579 (astore 14)) ;;at TAG_18
                                      (581 (aload 12)) 
                                      (583 (invokeinterface (methodCP "getValue" "java.util.Map$Entry" () (class "java.lang.Object")) 1)) 
                                      (588 (astore 15)) 
                                      (590 (aload 13)) 
                                      (592 (invokevirtual (methodCP "histCount" "clojure.lang.Ref" () int))) 
                                      (595 (istore 16)) 
                                      (597 (aload 13)) 
                                      (599 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (602 (ifnonnull 626)) ;;to TAG_19
                                      (605 (aload 13)) 
                                      (607 (new (class "clojure.lang.Ref$TVal"))) 
                                      (610 (dup)) 
                                      (611 (aload 15)) 
                                      (613 (lload 9)) 
                                      (615 (lload 7)) 
                                      (617 (invokespecial (methodCP "<init>" "clojure.lang.Ref$TVal" ((class "java.lang.Object") long long) void))) 
                                      (620 (putfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (623 (goto 735)) ;;to TAG_20
                                      (626 (aload 13)) ;;at TAG_19
                                      (628 (getfield (fieldCP "faults" "clojure.lang.Ref" (class "java.util.concurrent.atomic.AtomicInteger")))) 
                                      (631 (invokevirtual (methodCP "get" "java.util.concurrent.atomic.AtomicInteger" () int))) 
                                      (634 (ifle 647)) ;;to TAG_21
                                      (637 (iload 16)) 
                                      (639 (aload 13)) 
                                      (641 (getfield (fieldCP "maxHistory" "clojure.lang.Ref" int))) 
                                      (644 (if_icmplt 657)) ;;to TAG_22
                                      (647 (iload 16)) ;;at TAG_21
                                      (649 (aload 13)) 
                                      (651 (getfield (fieldCP "minHistory" "clojure.lang.Ref" int))) 
                                      (654 (if_icmpge 692)) ;;to TAG_23
                                      (657 (aload 13)) ;;at TAG_22
                                      (659 (new (class "clojure.lang.Ref$TVal"))) 
                                      (662 (dup)) 
                                      (663 (aload 15)) 
                                      (665 (lload 9)) 
                                      (667 (lload 7)) 
                                      (669 (aload 13)) 
                                      (671 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (674 (invokespecial (methodCP "<init>" "clojure.lang.Ref$TVal" ((class "java.lang.Object") long long (class "clojure.lang.Ref$TVal")) void))) 
                                      (677 (putfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (680 (aload 13)) 
                                      (682 (getfield (fieldCP "faults" "clojure.lang.Ref" (class "java.util.concurrent.atomic.AtomicInteger")))) 
                                      (685 (iconst_0)) 
                                      (686 (invokevirtual (methodCP "set" "java.util.concurrent.atomic.AtomicInteger" (int) void))) 
                                      (689 (goto 735)) ;;to TAG_20
                                      (692 (aload 13)) ;;at TAG_23
                                      (694 (aload 13)) 
                                      (696 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (699 (getfield (fieldCP "next" "clojure.lang.Ref$TVal" (class "clojure.lang.Ref$TVal")))) 
                                      (702 (putfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (705 (aload 13)) 
                                      (707 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (710 (aload 15)) 
                                      (712 (putfield (fieldCP "val" "clojure.lang.Ref$TVal" (class "java.lang.Object")))) 
                                      (715 (aload 13)) 
                                      (717 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (720 (lload 9)) 
                                      (722 (putfield (fieldCP "point" "clojure.lang.Ref$TVal" long))) 
                                      (725 (aload 13)) 
                                      (727 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (730 (lload 7)) 
                                      (732 (putfield (fieldCP "msecs" "clojure.lang.Ref$TVal" long))) 
                                      (735 (aload 13)) ;;at TAG_20
                                      (737 (invokevirtual (methodCP "getWatches" "clojure.lang.Ref" () (class "clojure.lang.IPersistentMap")))) 
                                      (740 (invokeinterface (methodCP "count" "clojure.lang.IPersistentMap" () int) 1)) 
                                      (745 (ifle 767)) ;;to TAG_24
                                      (748 (aload 5)) 
                                      (750 (new (class "clojure.lang.LockingTransaction$Notify"))) 
                                      (753 (dup)) 
                                      (754 (aload 13)) 
                                      (756 (aload 14)) 
                                      (758 (aload 15)) 
                                      (760 (invokespecial (methodCP "<init>" "clojure.lang.LockingTransaction$Notify" ((class "clojure.lang.Ref") (class "java.lang.Object") (class "java.lang.Object")) void))) 
                                      (763 (invokevirtual (methodCP "add" "java.util.ArrayList" ((class "java.lang.Object")) boolean))) 
                                      (766 (pop)) 
                                      (767 (goto 525)) ;;to TAG_25;;at TAG_24
                                      (770 (iconst_1)) ;;at TAG_16
                                      (771 (istore_2)) 
                                      (772 (aload_0)) 
                                      (773 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (776 (getfield (fieldCP "status" "clojure.lang.LockingTransaction$Info" (class "java.util.concurrent.atomic.AtomicInteger")))) 
                                      (779 (iconst_4)) 
                                      (780 (invokevirtual (methodCP "set" "java.util.concurrent.atomic.AtomicInteger" (int) void))) 
                                      (783 (jsr 805)) ;;to TAG_26;;at TAG_2
                                      (786 (goto 1041)) ;;to TAG_27;;at TAG_44
                                      (789 (astore 7)) ;;at TAG_43
                                      (791 (jsr 805)) ;;to TAG_26
                                      (794 (goto 1041)) ;;to TAG_27;;at TAG_46
                                      (797 (astore 17)) ;;at TAG_45
                                      (799 (jsr 805)) ;;to TAG_26
                                      (802 (aload 17)) ;;at TAG_47
                                      (804 (athrow)) 
                                      (805 (astore 18)) ;;at TAG_26
                                      (807 (aload 4)) 
                                      (809 (invokevirtual (methodCP "size" "java.util.ArrayList" () int))) 
                                      (812 (iconst_1)) 
                                      (813 (isub)) 
                                      (814 (istore 19)) 
                                      (816 (iload 19)) ;;at TAG_29
                                      (818 (iflt 846)) ;;to TAG_28
                                      (821 (aload 4)) 
                                      (823 (iload 19)) 
                                      (825 (invokevirtual (methodCP "get" "java.util.ArrayList" (int) (class "java.lang.Object")))) 
                                      (828 (checkcast (class "clojure.lang.Ref"))) 
                                      (831 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (834 (invokevirtual (methodCP "writeLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock")))) 
                                      (837 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock" () void))) 
                                      (840 (iinc 19 -1)) 
                                      (843 (goto 816)) ;;to TAG_29
                                      (846 (aload 4)) ;;at TAG_28
                                      (848 (invokevirtual (methodCP "clear" "java.util.ArrayList" () void))) 
                                      (851 (aload_0)) 
                                      (852 (getfield (fieldCP "ensures" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (855 (invokevirtual (methodCP "iterator" "java.util.HashSet" () (class "java.util.Iterator")))) 
                                      (858 (astore 19)) 
                                      (860 (aload 19)) ;;at TAG_31
                                      (862 (invokeinterface (methodCP "hasNext" "java.util.Iterator" () boolean) 1)) 
                                      (867 (ifeq 896)) ;;to TAG_30
                                      (870 (aload 19)) 
                                      (872 (invokeinterface (methodCP "next" "java.util.Iterator" () (class "java.lang.Object")) 1)) 
                                      (877 (checkcast (class "clojure.lang.Ref"))) 
                                      (880 (astore 20)) 
                                      (882 (aload 20)) 
                                      (884 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (887 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (890 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (893 (goto 860)) ;;to TAG_31
                                      (896 (aload_0)) ;;at TAG_30
                                      (897 (getfield (fieldCP "ensures" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (900 (invokevirtual (methodCP "clear" "java.util.HashSet" () void))) 
                                      (903 (aload_0)) 
                                      (904 (iload_2)) 
                                      (905 (ifeq 912)) ;;to TAG_32
                                      (908 (iconst_4)) 
                                      (909 (goto 913)) ;;to TAG_33
                                      (912 (iconst_2)) ;;at TAG_32
                                      (913 (invokevirtual (methodCP "stop" "clojure.lang.LockingTransaction" (int) void))) ;;at TAG_33
                                      (916 (iload_2)) ;;at TAG_48
                                      (917 (ifeq 1009)) ;;to TAG_34
                                      (920 (aload 5)) 
                                      (922 (invokevirtual (methodCP "iterator" "java.util.ArrayList" () (class "java.util.Iterator")))) 
                                      (925 (astore 19)) 
                                      (927 (aload 19)) ;;at TAG_36
                                      (929 (invokeinterface (methodCP "hasNext" "java.util.Iterator" () boolean) 1)) 
                                      (934 (ifeq 970)) ;;to TAG_35
                                      (937 (aload 19)) 
                                      (939 (invokeinterface (methodCP "next" "java.util.Iterator" () (class "java.lang.Object")) 1)) 
                                      (944 (checkcast (class "clojure.lang.LockingTransaction$Notify"))) 
                                      (947 (astore 20)) 
                                      (949 (aload 20)) 
                                      (951 (getfield (fieldCP "ref" "clojure.lang.LockingTransaction$Notify" (class "clojure.lang.Ref")))) 
                                      (954 (aload 20)) 
                                      (956 (getfield (fieldCP "oldval" "clojure.lang.LockingTransaction$Notify" (class "java.lang.Object")))) 
                                      (959 (aload 20)) 
                                      (961 (getfield (fieldCP "newval" "clojure.lang.LockingTransaction$Notify" (class "java.lang.Object")))) 
                                      (964 (invokevirtual (methodCP "notifyWatches" "clojure.lang.Ref" ((class "java.lang.Object") (class "java.lang.Object")) void))) 
                                      (967 (goto 927)) ;;to TAG_36
                                      (970 (aload_0)) ;;at TAG_35
                                      (971 (getfield (fieldCP "actions" "clojure.lang.LockingTransaction" (class "java.util.ArrayList")))) 
                                      (974 (invokevirtual (methodCP "iterator" "java.util.ArrayList" () (class "java.util.Iterator")))) 
                                      (977 (astore 19)) 
                                      (979 (aload 19)) ;;at TAG_37
                                      (981 (invokeinterface (methodCP "hasNext" "java.util.Iterator" () boolean) 1)) 
                                      (986 (ifeq 1009)) ;;to TAG_34
                                      (989 (aload 19)) 
                                      (991 (invokeinterface (methodCP "next" "java.util.Iterator" () (class "java.lang.Object")) 1)) 
                                      (996 (checkcast (class "clojure.lang.Agent$Action"))) 
                                      (999 (astore 20)) 
                                      (1001 (aload 20)) 
                                      (1003 (invokestatic (methodCP "dispatchAction" "clojure.lang.Agent" ((class "clojure.lang.Agent$Action")) void))) 
                                      (1006 (goto 979)) ;;to TAG_37
                                      (1009 (jsr 1023)) ;;to TAG_38;;at TAG_34
                                      (1012 (goto 1039)) ;;to TAG_39;;at TAG_49
                                      (1015 (astore 21)) ;;at TAG_50
                                      (1017 (jsr 1023)) ;;to TAG_38
                                      (1020 (aload 21)) ;;at TAG_51
                                      (1022 (athrow)) 
                                      (1023 (astore 22)) ;;at TAG_38
                                      (1025 (aload 5)) 
                                      (1027 (invokevirtual (methodCP "clear" "java.util.ArrayList" () void))) 
                                      (1030 (aload_0)) 
                                      (1031 (getfield (fieldCP "actions" "clojure.lang.LockingTransaction" (class "java.util.ArrayList")))) 
                                      (1034 (invokevirtual (methodCP "clear" "java.util.ArrayList" () void))) 
                                      (1037 (ret 22)) 
                                      (1039 (ret 18)) ;;at TAG_39
                                      (1041 (iinc 6 1)) ;;at TAG_27
                                      (1044 (goto 25)) ;;to TAG_40
                                      (1047 (iload_2)) ;;at TAG_0
                                      (1048 (ifne 1057)) ;;to TAG_41
                                      (1051 (ldc 10)) ;;STRING:: "Transaction failed after reaching retry limit"
                                      (1053 (invokestatic (methodCP "runtimeException" "clojure.lang.Util" ((class "java.lang.String")) (class "java.lang.RuntimeException")))) 
                                      (1056 (athrow)) 
                                      (1057 (aload_3)) ;;at TAG_41
                                      (1058 (areturn)) 
                                      (endofcode 1059))
                                   (Exceptions 
                                     (handler 37 783  789 (class "clojure.lang.LockingTransaction$RetryEx"))
                                     (handler 37 786  797 (class "java.lang.Throwable"))
                                     (handler 789 794  797 (class "java.lang.Throwable"))
                                     (handler 797 802  797 (class "java.lang.Throwable"))
                                     (handler 916 1012  1015 (class "java.lang.Throwable"))
                                     (handler 1015 1020  1015 (class "java.lang.Throwable")))
                                   (StackMap )))
                        (method "enqueue"
                              (parameters (class "clojure.lang.Agent$Action"))
                              (returntype . void)
                              (accessflags  *class*  *public* )
                              (code
                                   (max_stack . 2) (max_locals . 2) (code_length . 10)
                                   (parsedcode
                                      (0 (aload_0))
                                      (1 (getfield (fieldCP "actions" "clojure.lang.LockingTransaction" (class "java.util.ArrayList"))))
                                      (4 (aload_1))
                                      (5 (invokevirtual
					(methodCP "add" "java.util.ArrayList" ((class "java.lang.Object")) boolean)))
                                      (8 (pop))
                                      (9 (return))
                                      (endofcode 10))
                                   (Exceptions )
                                   (StackMap )))
                        (method "doGet"
                              (parameters (class "clojure.lang.Ref"))
                              (returntype . (class "java.lang.Object"))
                              (accessflags  *class* )
                              (code
                                   (max_stack . 4) (max_locals . 6) (code_length . 163)
                                   (parsedcode
                                      (0 (aload_0)) 
                                      (1 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (4 (invokevirtual (methodCP "running" "clojure.lang.LockingTransaction$Info" () boolean))) 
                                      (7 (ifne 15)) ;;to TAG_0
                                      (10 (aload_0)) 
                                      (11 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (14 (athrow)) 
                                      (15 (aload_0)) ;;at TAG_0
                                      (16 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (19 (aload_1)) 
                                      (20 (invokevirtual (methodCP "containsKey" "java.util.HashMap" ((class "java.lang.Object")) boolean))) 
                                      (23 (ifeq 35))  ;;to TAG_1
                                      (26 (aload_0)) 
                                      (27 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (30 (aload_1)) 
                                      (31 (invokevirtual (methodCP "get" "java.util.HashMap" ((class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (34 (areturn)) 
                                      (35 (aload_1)) ;;at TAG_1
                                      (36 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (39 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (42 (invokevirtual (methodCP "lock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (45 (aload_1)) 
                                      (46 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (49 (ifnonnull 82)) ;;to TAG_2
                                      (52 (new (class "java.lang.IllegalStateException"))) 
                                      (55 (dup)) 
                                      (56 (new (class "java.lang.StringBuilder"))) 
                                      (59 (dup)) 
                                      (60 (invokespecial (methodCP "<init>" "java.lang.StringBuilder" () void))) 
                                      (63 (aload_1)) 
                                      (64 (invokevirtual (methodCP "toString" "java.lang.Object" () (class "java.lang.String")))) 
                                      (67 (invokevirtual (methodCP "append" "java.lang.StringBuilder" ((class "java.lang.String")) (class "java.lang.StringBuilder")))) 
                                      (70 (ldc 11)) ;;STRING:: " is unbound."
                                      (72 (invokevirtual (methodCP "append" "java.lang.StringBuilder" ((class "java.lang.String")) (class "java.lang.StringBuilder")))) 
                                      (75 (invokevirtual (methodCP "toString" "java.lang.StringBuilder" () (class "java.lang.String")))) 
                                      (78 (invokespecial (methodCP "<init>" "java.lang.IllegalStateException" ((class "java.lang.String")) void))) 
                                      (81 (athrow)) 
                                      (82 (aload_1)) ;;at TAG_2
                                      (83 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (86 (astore_2)) 
                                      (87 (aload_2)) ;;at TAG_5
                                      (88 (getfield (fieldCP "point" "clojure.lang.Ref$TVal" long))) 
                                      (91 (aload_0)) 
                                      (92 (getfield (fieldCP "readPoint" "clojure.lang.LockingTransaction" long))) 
                                      (95 (lcmp)) 
                                      (96 (ifgt 109)) ;;to TAG_3
                                      (99 (aload_2)) 
                                      (100 (getfield (fieldCP "val" "clojure.lang.Ref$TVal" (class "java.lang.Object")))) 
                                      (103 (astore_3)) 
                                      (104 (jsr 136)) ;;to TAG_4
                                      (107 (aload_3)) ;;at TAG_7
                                      (108 (areturn)) 
                                      (109 (aload_2)) ;;at TAG_3
                                      (110 (getfield (fieldCP "prior" "clojure.lang.Ref$TVal" (class "clojure.lang.Ref$TVal")))) 
                                      (113 (dup)) 
                                      (114 (astore_2)) 
                                      (115 (aload_1)) 
                                      (116 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (119 (if_acmpne 87)) ;;to TAG_5
                                      (122 (jsr 136)) ;;to TAG_4
                                      (125 (goto 150)) ;;to TAG_6;;at TAG_9
                                      (128 (astore 4)) ;;at TAG_8
                                      (130 (jsr 136)) ;;to TAG_4
                                      (133 (aload 4)) ;;at TAG_10
                                      (135 (athrow)) 
                                      (136 (astore 5)) ;;at TAG_4
                                      (138 (aload_1)) 
                                      (139 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (142 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (145 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (148 (ret 5)) 
                                      (150 (aload_1)) ;;at TAG_6
                                      (151 (getfield (fieldCP "faults" "clojure.lang.Ref" (class "java.util.concurrent.atomic.AtomicInteger")))) 
                                      (154 (invokevirtual (methodCP "incrementAndGet" "java.util.concurrent.atomic.AtomicInteger" () int))) 
                                      (157 (pop)) 
                                      (158 (aload_0)) 
                                      (159 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (162 (athrow)) 
                                      (endofcode 163))
                                   (Exceptions 
                                     (handler 35 107  128 (class "java.lang.Throwable"))
                                     (handler 109 125  128 (class "java.lang.Throwable"))
                                     (handler 128 133  128 (class "java.lang.Throwable")))
                                   (StackMap )))
                        (method "doSet"
                              (parameters (class "clojure.lang.Ref") (class "java.lang.Object"))
                              (returntype . (class "java.lang.Object"))
                              (accessflags  *class* )
                              (code
                                   (max_stack . 3) (max_locals . 3) (code_length . 74)
                                   (parsedcode
                                      (0 (aload_0)) 
                                      (1 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (4 (invokevirtual (methodCP "running" "clojure.lang.LockingTransaction$Info" () boolean))) 
                                      (7 (ifne 15)) ;;to TAG_0
                                      (10 (aload_0)) 
                                      (11 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (14 (athrow)) 
                                      (15 (aload_0)) ;;at TAG_0
                                      (16 (getfield (fieldCP "commutes" "clojure.lang.LockingTransaction" (class "java.util.TreeMap")))) 
                                      (19 (aload_1)) 
                                      (20 (invokevirtual (methodCP "containsKey" "java.util.TreeMap" ((class "java.lang.Object")) boolean))) 
                                      (23 (ifeq 36)) ;;to TAG_1
                                      (26 (new (class "java.lang.IllegalStateException"))) 
                                      (29 (dup)) 
                                      (30 (ldc 12)) ;;STRING:: "Can\nt set after commute"
                                      (32 (invokespecial (methodCP "<init>" "java.lang.IllegalStateException" ((class "java.lang.String")) void))) 
                                      (35 (athrow)) 
                                      (36 (aload_0)) ;;at TAG_1
                                      (37 (getfield (fieldCP "sets" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (40 (aload_1)) 
                                      (41 (invokevirtual (methodCP "contains" "java.util.HashSet" ((class "java.lang.Object")) boolean))) 
                                      (44 (ifne 62))  ;;to TAG_2
                                      (47 (aload_0)) 
                                      (48 (getfield (fieldCP "sets" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (51 (aload_1)) 
                                      (52 (invokevirtual (methodCP "add" "java.util.HashSet" ((class "java.lang.Object")) boolean))) 
                                      (55 (pop)) 
                                      (56 (aload_0)) 
                                      (57 (aload_1)) 
                                      (58 (invokevirtual (methodCP "lock" "clojure.lang.LockingTransaction" ((class "clojure.lang.Ref")) (class "java.lang.Object")))) 
                                      (61 (pop)) 
                                      (62 (aload_0)) ;;at TAG_2
                                      (63 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (66 (aload_1)) 
                                      (67 (aload_2)) 
                                      (68 (invokevirtual (methodCP "put" "java.util.HashMap" ((class "java.lang.Object") (class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (71 (pop)) 
                                      (72 (aload_2)) 
                                      (73 (areturn)) 
                                      (endofcode 74))
                                   (Exceptions )
                                   (StackMap )))
                        (method "doEnsure"
                              (parameters (class "clojure.lang.Ref"))
                              (returntype . void)
                              (accessflags  *class* )
                              (code
                                   (max_stack . 4) (max_locals . 3) (code_length . 127)
                                   (parsedcode
                                      (0 (aload_0)) 
                                      (1 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (4 (invokevirtual (methodCP "running" "clojure.lang.LockingTransaction$Info" () boolean))) 
                                      (7 (ifne 15)) ;;to TAG_0
                                      (10 (aload_0)) 
                                      (11 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (14 (athrow)) 
                                      (15 (aload_0)) ;;at TAG_0
                                      (16 (getfield (fieldCP "ensures" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (19 (aload_1)) 
                                      (20 (invokevirtual (methodCP "contains" "java.util.HashSet" ((class "java.lang.Object")) boolean))) 
                                      (23 (ifeq 27)) ;;to TAG_1
                                      (26 (return)) 
                                      (27 (aload_1)) ;;at TAG_1
                                      (28 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (31 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (34 (invokevirtual (methodCP "lock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (37 (aload_1)) 
                                      (38 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (41 (ifnull 74))  ;;to TAG_2
                                      (44 (aload_1)) 
                                      (45 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (48 (getfield (fieldCP "point" "clojure.lang.Ref$TVal" long))) 
                                      (51 (aload_0)) 
                                      (52 (getfield (fieldCP "readPoint" "clojure.lang.LockingTransaction" long))) 
                                      (55 (lcmp)) 
                                      (56 (ifle 74))  ;;to TAG_2
                                      (59 (aload_1)) 
                                      (60 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (63 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (66 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (69 (aload_0)) 
                                      (70 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (73 (athrow)) 
                                      (74 (aload_1)) ;;at TAG_2
                                      (75 (getfield (fieldCP "tinfo" "clojure.lang.Ref" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (78 (astore_2)) 
                                      (79 (aload_2)) 
                                      (80 (ifnull 117)) ;;to TAG_3
                                      (83 (aload_2)) 
                                      (84 (invokevirtual (methodCP "running" "clojure.lang.LockingTransaction$Info" () boolean))) 
                                      (87 (ifeq 117)) ;;to TAG_3
                                      (90 (aload_1)) 
                                      (91 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (94 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (97 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (100 (aload_2)) 
                                      (101 (aload_0)) 
                                      (102 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (105 (if_acmpeq 126)) ;;to TAG_4
                                      (108 (aload_0)) 
                                      (109 (aload_2)) 
                                      (110 (invokespecial (methodCP "blockAndBail" "clojure.lang.LockingTransaction" ((class "clojure.lang.LockingTransaction$Info")) (class "java.lang.Object")))) 
                                      (113 (pop)) 
                                      (114 (goto 126)) ;;to TAG_4
                                      (117 (aload_0)) ;;at TAG_3
                                      (118 (getfield (fieldCP "ensures" "clojure.lang.LockingTransaction" (class "java.util.HashSet")))) 
                                      (121 (aload_1)) 
                                      (122 (invokevirtual (methodCP "add" "java.util.HashSet" ((class "java.lang.Object")) boolean))) 
                                      (125 (pop)) 
                                      (126 (return)) ;;at TAG_4
                                      (endofcode 127))
                                   (Exceptions )
                                   (StackMap )))
                        (method "doCommute"
                              (parameters (class "clojure.lang.Ref") (class "clojure.lang.IFn") (class "clojure.lang.ISeq"))
                              (returntype . (class "java.lang.Object"))
                              (accessflags  *class* )
                              (code
                                   (max_stack . 5) (max_locals . 7) (code_length . 184)
                                   (parsedcode
                                      (0 (aload_0)) 
                                      (1 (getfield (fieldCP "info" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$Info")))) 
                                      (4 (invokevirtual (methodCP "running" "clojure.lang.LockingTransaction$Info" () boolean))) 
                                      (7 (ifne 15)) ;;to TAG_0
                                      (10 (aload_0)) 
                                      (11 (getfield (fieldCP "retryex" "clojure.lang.LockingTransaction" (class "clojure.lang.LockingTransaction$RetryEx")))) 
                                      (14 (athrow)) 
                                      (15 (aload_0)) ;;at TAG_0
                                      (16 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (19 (aload_1)) 
                                      (20 (invokevirtual (methodCP "containsKey" "java.util.HashMap" ((class "java.lang.Object")) boolean))) 
                                      (23 (ifne 98))  ;;to TAG_1
                                      (26 (aconst_null)) 
                                      (27 (astore 4)) 
                                      (29 (aload_1)) ;;at TAG_7
                                      (30 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (33 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (36 (invokevirtual (methodCP "lock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (39 (aload_1)) 
                                      (40 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (43 (ifnonnull 50)) ;;to TAG_2
                                      (46 (aconst_null)) 
                                      (47 (goto 57)) ;;to TAG_3
                                      (50 (aload_1)) ;;at TAG_2
                                      (51 (getfield (fieldCP "tvals" "clojure.lang.Ref" (class "clojure.lang.Ref$TVal")))) 
                                      (54 (getfield (fieldCP "val" "clojure.lang.Ref$TVal" (class "java.lang.Object")))) 
                                      (57 (astore 4)) ;;at TAG_3
                                      (59 (jsr 73)) ;;to TAG_4
                                      (62 (goto 87)) ;;to TAG_5;;at TAG_8
                                      (65 (astore 5)) ;;at TAG_9
                                      (67 (jsr 73)) ;;to TAG_4
                                      (70 (aload 5)) ;;at TAG_10
                                      (72 (athrow)) 
                                      (73 (astore 6)) ;;at TAG_4
                                      (75 (aload_1)) 
                                      (76 (getfield (fieldCP "lock" "clojure.lang.Ref" (class "java.util.concurrent.locks.ReentrantReadWriteLock")))) 
                                      (79 (invokevirtual (methodCP "readLock" "java.util.concurrent.locks.ReentrantReadWriteLock" () (class "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock")))) 
                                      (82 (invokevirtual (methodCP "unlock" "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock" () void))) 
                                      (85 (ret 6)) 
                                      (87 (aload_0)) ;;at TAG_5
                                      (88 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (91 (aload_1)) 
                                      (92 (aload 4)) 
                                      (94 (invokevirtual (methodCP "put" "java.util.HashMap" ((class "java.lang.Object") (class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (97 (pop)) 
                                      (98 (aload_0)) ;;at TAG_1
                                      (99 (getfield (fieldCP "commutes" "clojure.lang.LockingTransaction" (class "java.util.TreeMap")))) 
                                      (102 (aload_1)) 
                                      (103 (invokevirtual (methodCP "get" "java.util.TreeMap" ((class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (106 (checkcast (class "java.util.ArrayList"))) 
                                      (109 (astore 4)) 
                                      (111 (aload 4)) 
                                      (113 (ifnonnull 135)) ;;to TAG_6
                                      (116 (aload_0)) 
                                      (117 (getfield (fieldCP "commutes" "clojure.lang.LockingTransaction" (class "java.util.TreeMap")))) 
                                      (120 (aload_1)) 
                                      (121 (new (class "java.util.ArrayList"))) 
                                      (124 (dup)) 
                                      (125 (invokespecial (methodCP "<init>" "java.util.ArrayList" () void))) 
                                      (128 (dup)) 
                                      (129 (astore 4)) 
                                      (131 (invokevirtual (methodCP "put" "java.util.TreeMap" ((class "java.lang.Object") (class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (134 (pop)) 
                                      (135 (aload 4)) ;;at TAG_6
                                      (137 (new (class "clojure.lang.LockingTransaction$CFn"))) 
                                      (140 (dup)) 
                                      (141 (aload_2)) 
                                      (142 (aload_3)) 
                                      (143 (invokespecial (methodCP "<init>" "clojure.lang.LockingTransaction$CFn" ((class "clojure.lang.IFn") (class "clojure.lang.ISeq")) void))) 
                                      (146 (invokevirtual (methodCP "add" "java.util.ArrayList" ((class "java.lang.Object")) boolean))) 
                                      (149 (pop)) 
                                      (150 (aload_2)) 
                                      (151 (aload_0)) 
                                      (152 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (155 (aload_1)) 
                                      (156 (invokevirtual (methodCP "get" "java.util.HashMap" ((class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (159 (aload_3)) 
                                      (160 (invokestatic (methodCP "cons" "clojure.lang.RT" ((class "java.lang.Object") (class "java.lang.Object")) (class "clojure.lang.ISeq")))) 
                                      (163 (invokeinterface (methodCP "applyTo" "clojure.lang.IFn" ((class "clojure.lang.ISeq")) (class "java.lang.Object")) 2)) 
                                      (168 (astore 5)) 
                                      (170 (aload_0)) 
                                      (171 (getfield (fieldCP "vals" "clojure.lang.LockingTransaction" (class "java.util.HashMap")))) 
                                      (174 (aload_1)) 
                                      (175 (aload 5)) 
                                      (177 (invokevirtual (methodCP "put" "java.util.HashMap" ((class "java.lang.Object") (class "java.lang.Object")) (class "java.lang.Object")))) 
                                      (180 (pop)) 
                                      (181 (aload 5)) 
                                      (183 (areturn)) 
                                      (endofcode 184))
                                   (Exceptions 
                                     (handler 29 62  65 (class "java.lang.Throwable"))
                                     (handler 65 70  65 (class "java.lang.Throwable")))
                                   (StackMap )))
                        (method "<clinit>"
                              (parameters )
                              (returntype . void)
                              (accessflags  *class*  *static* )
                              (code
                                   (max_stack . 2) (max_locals . 0) (code_length . 21)
                                   (parsedcode
                                      (0 (new (class "java.lang.ThreadLocal")))
                                      (3 (dup))
                                      (4 (invokespecial
					(methodCP "<init>" "java.lang.ThreadLocal" () void)))
                                      (7 (putstatic (fieldCP "transaction" "clojure.lang.LockingTransaction" (class "java.lang.ThreadLocal"))))
                                      (10 (new (class "java.util.concurrent.atomic.AtomicLong")))
                                      (13 (dup))
                                      (14 (invokespecial
					(methodCP "<init>" "java.util.concurrent.atomic.AtomicLong" () void)))
                                      (17 (putstatic (fieldCP "lastPoint" "clojure.lang.LockingTransaction" (class "java.util.concurrent.atomic.AtomicLong"))))
                                      (20 (return))
                                      (endofcode 21))
                                   (Exceptions )
                                   (StackMap ))))
            (interfaces)
            (accessflags  *class*  *public*  *super*  *synchronized* )
            (attributes
              (attribute "SourceFile")
              (attribute "InnerClasses")))))


(defconst *LockingTransaction-class-table*
  (make-static-class-decls 
   *clojure.lang.LockingTransaction*))

(defconst *package-name-map* 
  ("clojure.lang.LockingTransaction" . "clojure.lang"))

